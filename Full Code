#define BIT0 (1<<0)
#define BIT1 (1<<1)
#define BIT2 (1<<2)
#define BIT3 (1<<3)
#define BIT4 (1<<4)
#define BIT5 (1<<5)
#define BIT6 (1<<6)
#define BIT7 (1<<7)
#define GET_BIT0(VAR) VAR & BIT0
#define GET_BIT1(VAR) VAR & BIT1
#define GET_BIT2(VAR) VAR & BIT2
#define GET_BIT3(VAR) VAR & BIT3
#define GET_BIT4(VAR) VAR & BIT4
#define GET_BIT5(VAR) VAR & BIT5
#define GET_BIT6(VAR) VAR & BIT6
#define GET_BIT7(VAR) VAR & BIT7
#define IS_BIT0_HIGH(VAR) GET_BIT0(VAR)
#define IS_BIT1_HIGH(VAR) GET_BIT1(VAR)
#define IS_BIT2_HIGH(VAR) GET_BIT2(VAR)
#define IS_BIT3_HIGH(VAR) GET_BIT3(VAR)
#define IS_BIT4_HIGH(VAR) GET_BIT4(VAR)
#define IS_BIT5_HIGH(VAR) GET_BIT5(VAR)
#define IS_BIT6_HIGH(VAR) GET_BIT6(VAR)
#define IS_BIT7_HIGH(VAR) GET_BIT7(VAR)
#define IS_HIGH(VAR) VAR == 0xFF
#define IS_BIT0_LOW(VAR) ~(GET_BIT0(VAR))
#define IS_BIT1_LOW(VAR) ~(GET_BIT1(VAR))
#define IS_BIT2_LOW(VAR) ~(GET_BIT2(VAR))
#define IS_BIT3_LOW(VAR) ~(GET_BIT3(VAR))
#define IS_BIT4_LOW(VAR) ~(GET_BIT4(VAR))
#define IS_BIT5_LOW(VAR) ~(GET_BIT5(VAR))
#define IS_BIT6_LOW(VAR) ~(GET_BIT6(VAR))
#define IS_BIT7_LOW(VAR) ~(GET_BIT7(VAR))
#define IS_LOW(VAR) VAR == 0x00
#define SET_BIT0_HIGH(VAR) VAR |= BIT0
#define SET_BIT1_HIGH(VAR) VAR |= BIT1
#define SET_BIT2_HIGH(VAR) VAR |= BIT2
#define SET_BIT3_HIGH(VAR) VAR |= BIT3
#define SET_BIT4_HIGH(VAR) VAR |= BIT4
#define SET_BIT5_HIGH(VAR) VAR |= BIT5
#define SET_BIT6_HIGH(VAR) VAR |= BIT6
#define SET_BIT7_HIGH(VAR) VAR |= BIT7
#define SET_HIGH(VAR) VAR = 0xFF
#define SET_BIT0_LOW(VAR) VAR &= ~BIT0
#define SET_BIT1_LOW(VAR) VAR &= ~BIT1
#define SET_BIT2_LOW(VAR) VAR &= ~BIT2
#define SET_BIT3_LOW(VAR) VAR &= ~BIT3
#define SET_BIT4_LOW(VAR) VAR &= ~BIT4
#define SET_BIT5_LOW(VAR) VAR &= ~BIT5
#define SET_BIT6_LOW(VAR) VAR &= ~BIT6
#define SET_BIT7_LOW(VAR) VAR &= ~BIT7
#define SET_LOW(VAR) VAR = 0x00

// todo: change it to b1-4
#define godam PORTD = 0x06;
#define wara PORTD = 0x09;
#define yameen PORTD = 0x05;
#define yasar PORTD = 0x0A;

/*
buzzer: one analog
sonic: two digital
leds : two digital
DC   : four digital

*/
#define SONICTRIGDIR TRISC.B3
#define SONICTRIGPIN PORTC.B3
#define SONICECHODIR TRISC.B4
#define SONICECHOPIN PORTC.B4

#define BTNDISPDIR TRISB.B0
#define BTNDISPPIN PORTB.B0
#define DHT11PIN PORTD.B1
#define DHT11DIR TRISD.B1
sbit LCD_RS at RD2_bit;
sbit LCD_EN at RD3_bit;
sbit LCD_D4 at RD4_bit;
sbit LCD_D5 at RD5_bit;
sbit LCD_D6 at RD6_bit;
sbit LCD_D7 at RD7_bit;
sbit LCD_RS_Direction at TRISD2_bit;
sbit LCD_EN_Direction at TRISD3_bit;
sbit LCD_D4_Direction at TRISD4_bit;
sbit LCD_D5_Direction at TRISD5_bit;
sbit LCD_D6_Direction at TRISD6_bit;
sbit LCD_D7_Direction at TRISD7_bit;


unsigned char Check, T_byte1, T_byte2,
RH_byte1, RH_byte2, Ch;
unsigned Temp, RH, Sum;
unsigned int speed;
unsigned int v;
unsigned int dis = 0;
char dist[10];
char servot[12];
unsigned int oftmr0 = 0;

unsigned char myscaledVoltage;
unsigned char mysevenseg[10] = { 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F };
unsigned int angle;                                                  // Count value of high - pertaining to the angle
unsigned char HL;                                                    // High Low
unsigned int analog_read;
unsigned int count;
void ATD_init(void) {
    ADCON0 = 0x41;           // ON, Channel 0, Fosc/16== 500KHz, Dont Go
    ADCON1 = 0xCE;           // RA0 Analog, others are Digital, Right Allignment,
    TRISA = 0x01;
}
unsigned int ATD_read(void) {
    ADCON0 = ADCON0 | 0x04;  // GO
    while (ADCON0 & 0x04);    // wait until DONE
    return (ADRESH << 8) | ADRESL;
}
void DHT11_StartSignal() {
    DHT11DIR = 0; //Configure RD0 as output
    DHT11PIN = 0; //RD0 sends 0 to the sensor
    delay_ms(18);
    DHT11PIN = 1; //RD0 sends 1 to the sensor
    delay_us(30);
    DHT11DIR = 1; //Configure RD0 as input
}
void DHT11_CheckResponse() {
    Check = 0;
    delay_us(40);
    if (DHT11PIN == 0) {
        delay_us(80);
        if (DHT11PIN == 1) Check = 1; delay_us(40);
    }
}
char DHT11_ReadData1() {
    char i, j;
    for (j = 0; j < 8; j++) {
        while (!DHT11PIN); //Wait until PORTD.F0 goes HIGH
        delay_us(30);
        if (DHT11PIN == 0)
            i &= ~(1 << (7 - j)); //Clear bit (7-b)
        else {
            i |= (1 << (7 - j)); //Set bit (7-b)
            while (DHT11PIN);
        } //Wait until PORTD.F0 goes LOW
    }
    return i;
}
char DHT11_ReadData()
{
    RH_byte1 = DHT11_ReadData1();
    RH_byte2 = DHT11_ReadData1();
    T_byte1 = DHT11_ReadData1();
    T_byte2 = DHT11_ReadData1();
    Sum = DHT11_ReadData1();
}

void DHT11_Display()
{
    DHT11_StartSignal();
    DHT11_CheckResponse();
    if (Check == 1) {
        DHT11_ReadData();
        if (Sum == ((RH_byte1 + RH_byte2 + T_byte1 + T_byte2) & 0XFF)) {
            Temp = T_byte1;
            RH = RH_byte1;
            Lcd_Out(1, 6, "Temp: C");
            Lcd_Out(2, 2, "Humidity: %");
            LCD_Chr(1, 12, 48 + ((Temp / 10) % 10));
            LCD_Chr(1, 13, 48 + (Temp % 10));
            LCD_Chr(2, 12, 48 + ((RH / 10) % 10));
            LCD_Chr(2, 13, 48 + (RH % 10));
        }
        else {
            Lcd_Cmd(_LCD_CURSOR_OFF); // cursor off
            Lcd_Cmd(_LCD_CLEAR); // clear LCD
            Lcd_Out(1, 1, "Check sum error");
        }
    }
    else {
        Lcd_Out(1, 3, "No response");
        Lcd_Out(2, 1, "from the sensor");
    }
    delay_ms(1000);
}


//Note: in the schematic of this project the PWM controls the fan speed using potentiometer, we should look for this



unsigned int GetAngle()
{
    analog_read = ATD_read();
    analog_read = analog_read >> 2;  // divided by 4 ==> 0-255
    //angle = 0.5ms -> 1000 counts; 1.75ms -> 3500 counts
    count = 1000 + ((analog_read * 25) / 2.55);     //angle= 1000 + ((k*2500)/255); 1000count=500uS to 3500count =1750us
    if (count < 1000) count = 1000;      // 0.5ms
    if (count > 3500) count = 3500;      // 1.75ms
    return count;
}



unsigned int Distance() {
    //Trigger on RC3 ,, Echo on RC4

    int tdist = 5;

    SONICTRIGPIN = 1;               //TRIGGER HIGH
    delay_us(10);               //10uS Delay
    SONICTRIGPIN = 0;           //TRIGGER LOW

    while (!(SONICECHOPIN));           //Waiting for Echo
    TMR0 = 0;
    oftmr0 = 0;
    while (SONICECHOPIN);            //Waiting for Echo goes LOW

    tdist = oftmr0 * 256 + TMR0;   //Reads Timer Value
    tdist = tdist / 58.82;                //Converts Time to Distance
    return tdist;
}



void CCPPWM_init() { //Configure CCP1 at 2ms period with 50% duty cycle
    T2CON = 0b00000111;//enable Timer2 at Fosc/4 with 1:16 prescaler (8 uS percount 2000uS to count 250 counts)
    CCP1CON = 0x0C;//enable PWM for CCP1
    PR2 = 250;// 250 counts =8uS *250 =2ms period
    CCPR1L = 0;
}void MotorSpeed(unsigned int speed) {
    CCPR1L = speed;
}

unsigned int ReadSpeed()
{
    unsigned int v = ATD_read();
    return (((v >> 2) * 250) / 255);// 0-250
}
void servoserve()
{
    angle += 600;
}
void interrupt(void) {
    if (INTCON & 0x02)
    {

        servoserve();
        if (angle >= 3500)
            angle = 2200;
        INTCON = INTCON & 0xFD;
    }
    else if (INTCON & 0x04)
    {
        TMR0 = 0;
        oftmr0++;
        INTCON = INTCON & 0xFB;
    }
    else if ((PIR2 & 0x01)) {                                           // CCP1 interrupt
        if (HL) {                                // high
            CCPR2H = angle >> 8;
            CCPR2L = angle;
            HL = 0;                      // next time low
            CCP2CON = 0x09;              // compare mode, clear output on match
            TMR1H = 0;
            TMR1L = 0;
        }
        else {                                          //low
            CCPR2H = (40000 - angle) >> 8;       // 40000 counts correspond to 20ms
            CCPR2L = (40000 - angle);
            CCP2CON = 0x08;             // compare mode, set output on match
            HL = 1;                     //next time High
            TMR1H = 0;
            TMR1L = 0;
        }
        PIR2 = PIR2 & 0xFE;
    }
}

void Init()
{
    HL = 1;                // start high
    SONICTRIGDIR = 0;
    SONICECHODIR = 1;
    DHT11DIR = 1;

    TRISD = 0;
    ATD_init();
    CCPPWM_init();
    OPTION_REG = 0x00;
    TMR0 = 0;
    oftmr0 = 0;

    TMR1L = 0;
    TMR1H = 0;
    T1CON = 0x01;
    INTCON = 0B11110000;

    TRISC.B1 = 0;
    PIE2 = PIE2 | 0x01;      // Enable CCP1 interrupts
    CCP2CON = 0x08;        // Compare mode, set output on match
    CCPR2L = 2000;         // Value preset in a program to compare the TMR1L value to
    CCPR2H = 2000 >> 8;      // Value preset in a program to compare the TMR1H value to            - 1ms

    MotorSpeed(100);
}

void DCMOTOR()
{
    dis = Distance();
}
void main() {
    Lcd_Init();
    Lcd_Cmd(_LCD_CURSOR_OFF); // cursor off
    Lcd_Cmd(_LCD_CLEAR); // clear LCD
    Init();
    angle = 2200;
    while (1) {

        dis = Distance();
        Lcd_Cmd(_LCD_CLEAR); // clear LCD
        sprintl(&dist, "dis = %d", dis);
        Lcd_Out(1, 1, dist);
        delay_ms(250);


        //DHT11_Display();
        //DCMOTOR();
    }
}


